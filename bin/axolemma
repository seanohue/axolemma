#!/usr/bin/env node
const cli = require('commander')
const inquirer = require('inquirer')
const semver = require('semver')
const requiresNode = require('requires-node-version')
const pretty = require('pretty-print')
const {bold, green, blue, red} = require('chalk')

requiresNode('8.0.0')

const {version} = require('../package.json')

const ax = require('../')
const {isAlphanumeric, isPositiveNumber, isMapType, isPercentage} = require('./validation')
const {toInteger, toPercentage} = require('./filters')

cli.version(version)
cli.on('--help', () => {
  console.log(blue(`Type ${bold(green('axolemma'))} to start creating.`))
})

const {Separator} = inquirer
const STATE = {}

const questions = [

  /** General area metadata **/
  {
    type: 'input',
    name: 'areaTitle',
    message: blue('What would you like to title this area?'),
    validate: isAlphanumeric,
  },
  {
    type: 'confirm',
    name: 'customizeAreaInfo',
    message(answers) {
      const {areaTitle = 'this area'} = answers
      return blue(`Would you like to further customize ${areaTitle}? (e.g., the default mob respawn rate)`)
    }
  },
  {
    type: 'input',
    name: 'respawnTime',
    message(answers) {
      const {areaTitle = 'this area'} = answers
      return blue(`What should the default respawn rate be for ${areaTitle}? (in seconds)`)
    },
    when(answers) {
      return Boolean(answers.customizeAreaInfo)
    },
    filter: toInteger,
    validate: isPositiveNumber,
    default: 60
  },

  /** Area generation algo. input **/
  {
    type: 'input',
    name: 'width',
    message(answers) {
      const {areaTitle = 'this area'} = answers
      return blue(`What is the maximum width (x coordinate) of ${areaTitle}?`);
    },
    filter: toInteger,
    validate: isPositiveNumber,
    default: 10
  },
  {
    type: 'input',
    name: 'height',
    message(answers) {
      const {areaTitle = 'this area'} = answers
      return blue(`What is the maximum height (y coordinate) of ${areaTitle}?`);
    },
    filter: toInteger,
    validate: isPositiveNumber,
    default: 10
  },
  {
    type: 'input',
    name: 'depth',
    message(answers) {
      const {areaTitle = 'this area'} = answers
      return blue(`What is the maximum depth (z coordinate) of ${areaTitle}?`);
    },
    validate: isPositiveNumber,
    filter: toInteger,
    default: 1,
    when: false // Not supported yet.
  },
  {
    type: 'list',
    name: 'type',
    message: blue('What generation algorithm would you like to use?'),
    choices: [
      new Separator('-- Mazes --'),
      'DividedMaze',
      'IceyMaze',
      'EllerMaze',
      new Separator('-- Dungeons --'),
      'Digger',
      'Uniform',
      'Rogue',
      new Separator('-- Other --'),
      'Arena',
      'Cellular'
    ]
  },

  /** Algorihm-specific settings **/
  {
    when: isMapType('IceyMaze'),
    type: 'input',
    name: 'regularity',
    message(answers) {
      const {type} = answers
      return blue(`[${type}] What will the regularity of this maze be? 0 = most random, higher numbers = less random.`)
    },
    validate: isPositiveNumber,
    default: 0
  },
  // {
  //   when: isMapType('Cellular'),
  //   type: 'input',
  //   name: ''
  // }
  {
    when: isMapType('Digger'),
    type: 'input',
    name: 'roomHeightMaximum',
    message(answers) {
      const {type} = answers
      return blue(`[${type}] What will be the maximum height (y value) for each generated "room"?`)
    },
    filter: toInteger,
    validate(input, answers) {
      const {height} = answers
      return (isPositiveNumber(input) && input < height) || `Please enter a numeric value that is less than ${height}.`
    }
  },
  {
    when: isMapType('Digger'),
    type: 'input',
    name: 'roomHeightMinimum',
    message(answers) {
      const {type} = answers
      return blue(`[${type}] What will be the minimum height (y value) for each generated "room"?`)
    },
    validate(input, answers) {
      const {roomHeightMaximum} = answers
      return (isPositiveNumber(input) && input < roomHeightMaximum - 1) || `Please enter a numeric value that is less than ${roomHeightMaximum - 1}.`
    },
    filter: toInteger
  },
  {
    when: isMapType('Digger'),
    type: 'input',
    name: 'roomHeightMaximum',
    message(answers) {
      const {type} = answers
      return blue(`[${type}] What will be the maximum width (x value) for each generated "room"?`)
    },
    filter: toInteger,
    validate(input, answers) {
      const {height} = answers
      return (isPositiveNumber(input) && input < height) || `Please enter a numeric value that is less than ${height}.`
    }
  },
  {
    when: isMapType('Digger'),
    type: 'input',
    name: 'roomHeightMinimum',
    message(answers) {
      const {type} = answers
      return blue(`[${type}] What will be the minimum width (x value) for each generated "room"?`)
    },
    validate(input, answers) {
      const {roomHeightMaximum, height} = answers
      return (isPositiveNumber(input) && input < roomHeightMaximum - 1) || `Please enter a numeric value that is less than ${roomHeightMaximum - 1}.`
    },
    filter: toInteger
  },
  {
    when: isMapType('Digger'),
    type: 'input',
    name: 'corridorLengthMaximum',
    message(answers) {
      const {type} = answers
      return blue(`[${type}] What will be the maximum length for each generated "corridor"?`)
    },
    validate(input, answers) {
      const {height, width} = answers
      const max = Math.min(height, width)
      return (isPositiveNumber(input) && input < max) || `Please enter a positive numeric value that is less than ${max}.`
    },
    filter: toInteger,
  },
  {
    when: isMapType('Digger'),
    type: 'input',
    name: 'corridorLengthMinimum',
    message(answers) {
      const {type} = answers
      return blue(`[${type}] What will be the minimum length for each generated "corridor"?`)
    },
    validate(input, answers) {
      const {height, width, corridorLengthMaximum} = answers
      const max = Math.min(height, width, corridorLengthMaximum - 1)
      return (isPositiveNumber(input) && input < max) || `Please enter a positive numeric value that is less than ${max}.`
    },
    filter: toInteger
  },
  {
    when: isMapType('Digger'),
    type: 'input',
    name: 'dugPercentage',
    message(answers) {
      const {type} = answers
      return blue(`[${type}] What percentage of the map area should be turned into rooms?`)
    },
    default: 0.25,
    validate: isPercentage,
    filter: toPercentage
  },
  {
    when: isMapType('Digger'),
    type: 'input',
    name: 'timeLimit',
    message(answers) {
      const {type} = answers
      return blue(`[${type}] How long do you want to wait before causing the algorithm to time out (in ms)?`)
    },
    default: 60 * 1000,
    validate: isPositiveNumber
  },

  /** Confirmation steps. **/
  {
    type: 'confirm',
    name: 'confirmedSettings',
    message(answers) {
      const printable = Object.assign({}, answers)

      // Delete props we won't pass to the final builder.
      delete printable.customizeAreaInfo;

      pretty(printable)
      return blue('Confirm settings before generating?')
    }
  },

  {
    type: 'confirm',
    name: 'confirmedGeneratedMap',
    when(answers) {
      const {confirmedSettings} = answers;

      // Cheap. Have it restart from beginning instead
      // or allow user to edit options directly using editor mode.
      if (!confirmedSettings) {
        console.log(red('Try, try again.'));
        process.exit(1);
      }
      return true;
    },
    message(answers) {
      console.log(blue('Generating map...'));
      const overrides = {
        writeToFile: false //true if not in testing.
      }
      const axOptions = Object.assign({},
        answers,
        overrides
      )
      const {graphic, buildCallback} = ax.generate(options)
      STATE.buildCallback = buildCallback
      STATE.rooms = rooms
      console.log(bold(graphic));
      return blue('Would you like to write this map to disk?')
    }
  }
]

inquirer.prompt(questions)
        .then(function(answers) {
          if (answers.confirmedGeneratedMap && STATE.buildCallback) {
            STATE.buildCallback(/* true for write to file? */)
          } else {
            console.log(red('Try, try again...'))
            console.log('Here are the rooms in case you change your mind:')
            console.log(STATE.rooms)
            process.exit(1)
          }
          process.exit(0)
        })
        .catch(console.error)


